function [image,exposureTime] = PDCExposureImage(image,camera)% [image,exposureTime] = PDCExposureImage(image,camera)%% Determine the exposure time appropriate for the passed image,% and convert image data for exposure time.  A photon image% computed for the camera should be passed.%% xx/xx/xx  pc  Wrote it.% 5/3/99    dhb Modified to work in context of SimulatorToolbox.% Find out much of well-capacity is used for each sensor[m,n,p] = size(camera.spatialLayout.mosaic);nDurations = size(image.exposureDuration);if (nDurations ~= 1 & nDurations ~= camera.numberSensors)	error('PDCExposureControl: number of durations must be 1 or number of sensors');end% Compute how strongly photon image drives the pixel wells.fillup = zeros(camera.numberSensors);for i1 = 1:camera.numberSensors	wellFillup = PDCCheckWellFillup(image.images(:,:,i1),image.exposureDuration(i1));	fillup(i1) = wellFillup.maxValue;endif (m == 1 & n == 1 & p > 1 & nDurations == p)     Fillup(1) = wellFillup.maxValue;   wellFillup = checkWellFillup(photonImage(:,:,:,2),cmosChip,integrationTime(2),spatialResolution);   Fillup(2) = wellFillup.maxValue;   wellFillup = checkWellFillup(photonImage(:,:,:,3),cmosChip,integrationTime(3),spatialResolution);   Fillup(3) = wellFillup.maxValue;else   testImage = photonImage(:,:,:,1)+photonImage(:,:,:,2)+photonImage(:,:,:,3);   wellFillup = checkWellFillup(testImage,cmosChip,integrationTime(1),spatialResolution);		Fillup = wellFillup.maxValue;end% Determine actual exposure based on timing methodswitch (camera.pdc.timing)	% Optimize most intense pixel across channels	case 'traditional',		image.exposureDuration = 0.9*image.exposureDuration./fillup;		image.exposureDuration = min(image.exposureDuration)*ones(size(image.exposureDuration));	% Optimize most intense pixel in each channel.  Only makes	% sense for field sequential architectures.	case 'optimized',		if (m == 1 & n == 1 & p > 1 & nDurations == p)			image.exposureDuration = 0.9*image.exposureDuration./fillup;		else			error('PDCExposureControl: optimized timing is only supported for field sequential cameras\n');		end  % This exposure control optimizes the time so that all channels fit in  % the time for CFA but with the color channels balanced as in the optimized  % timing.  Useful for comparisons between architectures.	case 'balanced',		if (m == 1 & n == 1 & p > 1 & nDurations == p)			image.exposureDuration = 0.9*image.exposureDuration./fillup;			image.exposureDuration = image.exposureDuration * ...				min(image.exposureDuration)/sum(image.exposureDuration); 		else			error('PDCExposureControl: balanced timing is only supported for field sequential cameras\n');		end	case 'gray world',		if (m == 1 & n == 1 & p > 1 & nDurations == p)			spatialAverage = zeros(size(image.exposureDuration));			for i1 = 1:camera.numberSensors				spatialAverage(i1) = mean2(image.images(:,:,i1));			end			image.exposureDuration = 0.9*image.exposureDuration./fillup;			image.expsureDuration = min(spatialAverage)*image.exposureDuration./spatialAverage;		else			error('PDCExposureControl: gray world timing is only supported for field sequential cameras\n');		end	% Unsupported.	otherwise		error(sprintf('PDCExposureControl: unsupported timing type %s requested',camera.pdc.timing));end% Adjust image for new exposure time.  So what we get is an image appropriate% for the determined exposure duration(s).if (nDurations > 1)	for i1 = 1:camera.numberSensors		image.images(:,:,i1) = image.images(:,:,i1)*image.exposureDuration(i1);	endelse	image.images = image.images * image.exposureDuration;end